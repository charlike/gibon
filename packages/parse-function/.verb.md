## Which version to use?

There's no breaking changes between the `v2.x` version. The only breaking is `v2.1` which also is not
working properly, so no use it.

**Use v2.0.x**

When you don't need support for `arrow functions` and `es6 default params`. This version
uses a RegExp expression to work.

**Use v2.2.x**

Only when you need a _basic_ support for `es6 features` like arrow functions. This version
uses a RegExp expression to work.

**Use v2.3.x**

When you want _full\*_ support for `arrow functions` and `es6 default params`. Where this "full",
means "almost full", because it has bugs. This version also uses (`acorn.parse`) real parser
to do the parsing.

**Use v3.x**

When you want to use different parser instead of the default `babylon.parse`, by passing custom
parse function to the `options.parse` option. **From this version we require `node >= 4`**.

**Use v4.x**

When you want full customization and most stable support for old and modern features. This version
uses `babylon.parseExpression` for parsing and provides a [Plugins API](#plugins-architecture).
See the [Features](#features) section for more info.

**Use v5.x**

It is basically the same as `v4`, but requires Node 6 & npm 5. Another is boilerplate stuff.

**[back to top](#readme)**

## Notes

### Throws in one specific case

> _see: [issue #3](https://github.com/tunnckoCore/parse-function/issues/3) and [test/index.js#L229-L235](https://github.com/tunnckoCore/parse-function/blob/master/test/index.js#L229-L235)_

It may throw in one specific case, otherwise it won't throw, so you should
relay on the `result.isValid` for sure.

### Function named _"anonymous"_

> _see: [test/index.js#L319-L324](https://github.com/tunnckoCore/parse-function/blob/master/test/index.js#L319-L324) and [Result](#result) section_

If you pass a function which is named _"anonymous"_ the `result.name` will be `'anonymous'`,
but the `result.isAnonymous` will be `false` and `result.isNamed` will be `true`, because
in fact it's a named function.

### Real anonymous function

> _see: [test/index.js#L326-L331](https://github.com/tunnckoCore/parse-function/blob/master/test/index.js#L326-L331) and [Result](#result) section_

Only if you pass really an anonymous function you will get `result.name` equal to `null`,
`result.isAnonymous` equal to `true` and `result.isNamed` equal to `false`.

**[back to top](#readme)**

### Plugins Architecture

> _see: the [.use](#use) method, [test/index.js#L305-L317](https://github.com/tunnckoCore/parse-function/blob/master/test/index.js#L305-L317) and [test/index.js#L396-L414](https://github.com/tunnckoCore/parse-function/blob/master/test/index.js#L396-L414)_

A more human description of the plugin mechanism. Plugins are **synchronous** - no support
and no need for **async** plugins here. Plugins MAY or MAY NOT return Result object, so
don't worry if you miss to return something.

```js
import { parseFunction } from 'parse-function';

function someFn(foo, bar) {
  return foo + bar;
}

const plugins = [
  (node, result) => {
    return { ...result, zaz: 111 };
  },
  (node, result) => {
    return { qux: result.zaz + 202 };
  },
];

const res = parseFunction(someFn, { plugins });
console.log(res);

console.log(res.name); // => 'someFn'
console.log(res.zaz); // => 111
console.log(res.qux); // => 313
```

If you want to access the AST of the parser, use the `node` parameter of the plugin.

Where **1)** the `node` argument is an object - actual and real AST Node coming from the parser
and **2)** the `result` is an object too - the end [Result](#result), on which
you can add more properties if you want.

**[back to top](#readme)**

<!-- docks-start -->

## API

_Generated using [jest-runner-docs](https://npmjs.com/package/jest-runner-docs)._

### [.parseFunction](./src/index.js#L84)

Parse a given `input` and returns a `Result` object
with useful properties - such as `name`, `body` and `args`.
By default it uses `@babel/parser` parser, but you can switch it by
passing `options.parse` or `options.parseExpression`, for example `options.parse: acorn.parse`.
In the below example will show how to use `acorn` parser, instead
of the default one.

**Signature**

```ts
function(input, options)
```

**Params**

- `input` - any kind of function or string to be parsed
- `options` - directly passed to the parser babylon, acorn, espree
- `options.parse` - by default `@babel/parser`'s `.parse` or `.parseExpression`,
- `options.parserOptions` - passed to the parser
- `options.plugins` - a plugin function like `function plugin(node: Node, result: Result): Result {}`
- `returns` - result object of the `Result`, see [result section](#result) for more info

**Example**

```js
import { parse as acornParse } from 'acorn';
import { parse as espreeParse } from 'espree';
import { parseFunction } from 'parse-function';

// or in CommonJS
// const { parseFunction } = require('parse-function');
// const parseFunction = require('parse-function').parseFunction;
// const fn = require('parse-function');
// fn.parseFunction()

function fooFn(bar, baz = 123) {
  return bar + baz;
}

const result1 = parseFunction(fooFn, { parse: acornParse });
console.log(result1);

const result2 = parseFunction(fooFn, {
  parse: espreeParse,
  parserOptions: {
    ecmaVersion: 9,
    sourceType: 'module',
    ecmaFeatures: { jsx: true, globalReturn: true },
  },
});

console.log('parsed with espree', result2);
// => {
//  name: 'fooFn',
//  body: '\n  return bar + baz;\n',
//  args: [ 'bar', 'baz' ],
//  params: 'bar, baz',
//  defaults: { bar: undefined, baz: '123' },
//  value: '(function fooFn(bar, baz = 123) {\n  return bar + baz;\n})',
//  isValid: true,
//  isArrow: false,
//  isAsync: false,
//  isNamed: true,
//  isAnonymous: false,
//  isGenerator: false,
//  isExpression: false,
//  bobby: 'bobby',
//  barry: 'barry barry',
//  hasDefaultParams: true
// }

function basicPlugin(node, result) {
  const bar = 'barry';
  const hasDefaultParams =
    Object.values(result.defaults).filter(Boolean).length > 0;

  return { ...result, foo: 123, bar, hasDefaultParams };
}

const resultWithPlugins = parseFunction(fooFn, { plugins: basicPlugin });
console.log(resultWithPlugins.name); // => 'fooFn'
console.log(resultWithPlugins.foo); // => 123
console.log(resultWithPlugins.bar); // => 'barry'
console.log(resultWithPlugins.hasDefaultParams); // => true
```

<!-- docks-end -->

## Result

> In the result object you have `name`, `args`, `params`, `body` and few hidden properties
> that can be useful to determine what the function is - arrow, regular, async/await or generator.

- `name` **{string|null}** - name of the passed function or `null` if anonymous
- `body` **{string}** - actual body of the function, respects trailing newlines and whitespaces
- `args` **{ResultArgs}** - an array of arguments of the function, `result.params` split by `,`
- `params` **{string}** - comma-separated list representing the `args`
- `defaults` **{ResultDefaultParams}** - key/value pairs, useful when use ES2015 default arguments
- `value` **{string}** - string value of what actually has been parsed
- `isValid` **{boolean}** - is the given value valid or not, that's because it never throws!
- `isArrow` **{boolean}** - `true` if the function is arrow function
- `isAsync` **{boolean}** - `true` if function is ES2015 async/await function
- `isNamed` **{boolean}** - `true` if function has name, or `false` if is anonymous
- `isAnonymous` **{boolean}** - `true` if the function don't have name
- `isGenerator` **{boolean}** - `true` if the function is ES2015 generator function
- `isExpression` **{boolean}** - `true` if the value parsed is an expression

## Types

```ts
import { ParserOptions } from '@babel/parser';
import { File } from '@babel/types';

type FnType = (...args: any) => any;

export type Input = FnType | string;
export type Plugin = (node: any, result: Result) => Result | undefined;
export type Plugins = Plugin | Array<Plugin>;
export type ResultDefaultParams = { [key: string]: string | undefined };
export type ResultArgs = string[];

export type Options = {
  parse?(input: string, options?: ParserOptions): File;
  parseExpression?(input: string, options?: ParserOptions): File;
  parserOptions?: ParserOptions;
  plugins?: Plugins;
};

export type Result = {
  name: string | null;
  body: string;
  args: ResultArgs;
  params: string;
  defaults: ResultDefaultParams;
  value: string;
  isValid: boolean;
  isArrow: boolean;
  isAsync: boolean;
  isNamed: boolean;
  isAnonymous: boolean;
  isGenerator: boolean;
  isExpression: boolean;
};

export function parseFunction(code: Input, options?: Options): Result;
```
